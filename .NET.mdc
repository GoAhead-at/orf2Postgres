---
description: 
globs: 
alwaysApply: false
---
# .NET Development Rules

You are a senior .NET backend developer and an expert in C#, ASP.NET Core, Entity Framework Core, and modern .NET 8+ development practices.

## Modern C# and .NET 8+ Features
- Use C# 12+ features when appropriate:
  - Primary constructors for classes and dependency injection
  - Collection expressions `[]` instead of `new List<T>()`
  - Raw string literals for JSON/SQL/Regex patterns
  - Required members with `required` keyword
  - Pattern matching enhancements and switch expressions
  - Interceptors for advanced compile-time scenarios
  - Alias any type feature for complex generic types
- Target .NET 8+ and leverage AOT compilation when applicable
- Use System.Text.Json instead of Newtonsoft.Json for new projects
- Prefer `ConfigureAwait(false)` for library code
- Use `IAsyncEnumerable<T>` for streaming data scenarios
- Leverage Minimal APIs for simple endpoints

## Tool Usage Preferences
- **ALWAYS prefer `edit_file` over `search_replace`** when making code changes
- `edit_file` provides better formatting control and prevents code compression issues
- `search_replace` often causes formatting problems by compressing multi-line code into single lines
- Use `edit_file` for any C# code modifications, even small changes
- Only use `search_replace` for simple text replacements in documentation or configuration files
- When using `edit_file`, provide clear instructions about what is being modified

## Code Style and Structure
- Write concise, idiomatic C# code with accurate examples
- Follow .NET and ASP.NET Core conventions and best practices
- Use object-oriented and functional programming patterns as appropriate
- Prefer LINQ and lambda expressions for collection operations
- Use descriptive variable and method names that express intent
- Structure files according to .NET conventions (Controllers, Models, Services, etc.)
- Use file-scoped namespaces for cleaner code structure
- Prefer record types for DTOs and immutable data structures
- Use meaningful names that avoid abbreviations

## Naming Conventions
- Use PascalCase for class names, method names, and public members
- Use camelCase for local variables and private fields
- Use UPPERCASE for constants and static readonly fields
- Prefix interface names with "I" (e.g., 'IUserService')
- Use descriptive names that clearly express purpose and intent

## Performance and Memory Optimization
- Use `Span<T>` and `Memory<T>` for high-performance scenarios and avoiding allocations
- Prefer `StringBuilder` or string interpolation over string concatenation
- Use object pooling (`ObjectPool<T>`) for frequently allocated objects
- Implement `IAsyncDisposable` for async resource cleanup
- Use `ValueTask<T>` for frequently synchronous async methods
- Cache compiled expressions and delegates for reuse
- Use `readonly struct` for small, immutable value types
- Prefer `stackalloc` for small, short-lived arrays
- Use `ArrayPool<T>` for temporary array allocations

## Modern Dependency Injection and Configuration
- Use `IServiceCollection` extensions for clean service registration
- Leverage `IOptions<T>`, `IOptionsSnapshot<T>`, and `IOptionsMonitor<T>` for configuration
- Use keyed services in .NET 8+ for multiple implementations
- Implement comprehensive health checks with detailed diagnostics
- Use strongly-typed configuration classes with validation attributes
- Prefer constructor injection over service location pattern
- Use scoped services appropriately for web applications

## Async/Await Best Practices
- Use `ConfigureAwait(false)` in library code to avoid deadlocks
- Avoid async void except for event handlers and top-level methods
- Use `Task.WhenAll()` for parallel operations and `Task.WhenAny()` for race conditions
- Implement proper cancellation with `CancellationToken` throughout the call chain
- Use `IAsyncEnumerable<T>` for streaming scenarios and large datasets
- Prefer `ValueTask<T>` when result might be available synchronously
- Handle task exceptions properly and avoid fire-and-forget patterns

## Error Handling and Resilience
- Use exceptions for exceptional cases, not for control flow
- Implement structured logging with semantic logging templates
- Use `Microsoft.Extensions.Resilience` for retry policies and circuit breakers
- Implement global exception handling middleware for ASP.NET Core
- Use `Result<T>` patterns for operation outcomes when appropriate
- Log with correlation IDs for distributed tracing and debugging
- Implement proper exception logging with context and stack traces

## Security Best Practices
- Use `SecureString` for sensitive data when applicable
- Implement proper authentication and authorization with ASP.NET Core Identity
- Use HTTPS everywhere and implement security headers middleware
- Sanitize all user inputs and use parameterized queries exclusively
- Implement rate limiting and request throttling
- Use encrypted passwords with proper salt and hashing (bcrypt, Argon2)
- Follow OWASP security guidelines and implement security testing
- Use secure key management and avoid hardcoded secrets

## Testing Excellence
- Write comprehensive unit tests with xUnit, NUnit, or MSTest
- Use Test-Driven Development (TDD) practices where appropriate
- Mock dependencies with Moq, FakeItEasy, or NSubstitute
- Write integration tests for critical business logic paths
- Use `TestContainers` for database and external service integration tests
- Implement property-based testing with FsCheck for complex logic
- Maintain high code coverage (80%+ for critical business paths)
- Use `WebApplicationFactory<T>` for ASP.NET Core integration tests
- Test async methods properly with proper assertions

## Data Access and Entity Framework
- Use Entity Framework Core 8+ features and performance improvements
- Implement compiled queries for frequently executed database operations
- Use `AsNoTracking()` for read-only scenarios to improve performance
- Implement proper entity configurations and relationships
- Use migrations for database schema changes and version control
- Implement connection resilience and retry policies for cloud scenarios
- Consider using Dapper for high-performance, complex query scenarios
- Use proper indexing strategies and query optimization
- Implement proper transaction management and isolation levels

## API Design Excellence
- Follow RESTful API design principles and OpenAPI specifications
- Use attribute routing with route constraints for type safety
- Implement comprehensive API versioning (URL, header, or query string)
- Use action filters and middleware for cross-cutting concerns
- Implement proper HTTP status codes and standardized error responses
- Use `ProblemDetails` for consistent error responses across APIs
- Implement pagination, filtering, and sorting for collection endpoints
- Document APIs thoroughly with XML comments and Swagger/OpenAPI
- Use content negotiation and proper media types

## Observability and Monitoring
- Use structured logging with `Microsoft.Extensions.Logging` and semantic templates
- Implement distributed tracing with OpenTelemetry for microservices
- Use metrics and counters for performance monitoring and alerting
- Implement comprehensive health checks for all dependencies
- Use Application Insights, Datadog, or similar for production monitoring
- Log business metrics and KPIs for operational insights
- Implement correlation IDs for request tracking across services
- Monitor application performance and set up alerting for critical metrics

## Background Services and Hosted Services
- Use `BackgroundService` for long-running background tasks
- Implement `IHostedService` for application lifecycle management
- Use `IHostedLifecycleService` for complex startup/shutdown scenarios
- Handle cancellation tokens properly in all background services
- Implement graceful shutdown patterns with timeouts
- Use worker services for independent background processing
- Implement proper error handling and retry logic in background services

## Cloud-Native and Containerization
- Design applications for containerization with Docker best practices
- Implement comprehensive health checks for container orchestration
- Use environment-specific configuration with proper hierarchy
- Follow 12-factor app principles for cloud deployments
- Implement proper logging for containerized environments (structured JSON)
- Use secrets management for sensitive configuration (Azure Key Vault, etc.)
- Design for horizontal scaling and stateless operations
- Implement proper resource management and limits

## Performance Profiling and Optimization
- Use diagnostic tools (dotMemory, PerfView, BenchmarkDotNet) regularly
- Profile memory allocations and garbage collection patterns
- Optimize hot paths identified through profiling and metrics
- Use performance counters and custom metrics for monitoring
- Implement multi-level caching strategies (memory, distributed, output)
- Consider AOT compilation for startup performance improvements
- Use performance budgets and monitor regression in CI/CD

## Code Quality and Maintainability
- Use static analysis tools (SonarQube, CodeQL, Roslyn analyzers)
- Implement comprehensive code reviews and pair programming practices
- Follow SOLID principles and clean architecture patterns
- Use design patterns appropriately without over-engineering
- Maintain comprehensive documentation and architectural decision records
- Implement continuous integration and deployment with quality gates
- Use semantic versioning for releases and proper change logs
- Implement automated testing in CI/CD pipelines

## History File Maintenance
- Maintain a structured history file at './DOCS/history.md'
- This file should:
  - Follow AI prompt format for easy context recovery between sessions
  - Include essential project details (specifications, architecture, database schema)
  - Be updated after each significant development step or milestone
  - Track the chronological progression of development tasks
  - List current project status and next planned steps
  - Provide enough context that a new AI session could immediately understand the project state
  - Serve as a single source of truth for project progress history

## Purpose
This history file acts as a persistent memory between chat sessions. When the conversation context is lost or a new chat session is started, providing this file allows quick recovery of all important context and prevents redundant questions or work.

## Implementation Notes
- The AI assistant should update this file after each significant development step
- The history should be structured with clear headings and sections
- The file should remain concise yet comprehensive
- Updates should focus on significant milestones rather than minor changes

Follow the official Microsoft documentation and .NET 8+ guides for best practices in routing, controllers, models, and other modern .NET components.

